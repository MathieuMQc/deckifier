#!/usr/bin/env python3

import sys
import os
import shutil
import argparse
import traceback
import subprocess
import queue
import threading
import copy
import logging
import contextlib
import tkinter as tk
import json

import logging as logging_module
logger = logging_module.getLogger(__name__)

import signalslot

import steam_devkit.utils
import steam_devkit.utils.resolve


SERVICE_EXECUTABLE_NAME = 'steamos-devkit-service'
ENTRY_POINT_EXECUTABLE_NAME = 'devkit-1'


class LoggingToUI(logging_module.Handler):
    def __init__(self):
        super(LoggingToUI, self).__init__()

        # -- signals --
        self.signal_log_record = signalslot.Signal(args=['record'])

    def setup(self):
        logging_module.root.addHandler(self)

    def emit(self, record):
        self.signal_log_record.emit(record=record)


class UI(object):
    def __init__(self, conf):
        self.cont = conf
        self.parent = None
        self.print_queue = queue.Queue()

        self.signal_exit_button = signalslot.Signal()

    def setup(self):
        self.text_console = tk.Text(self.parent, wrap=tk.NONE)
        self.text_console.pack(fill=tk.BOTH, expand=1, padx=5)

        self.button_exit = tk.Button(self.parent, text='Exit')
        self.button_exit.bind('<Button-1>', self.onButtonExit)
        self.button_exit.pack(anchor=tk.SE)

        self.logging_to_ui = LoggingToUI()
        self.logging_to_ui.setup()
        self.logging_to_ui.signal_log_record.connect(self.onSignalLogRecord)

        self.parent.after_idle(self.pump)

    def onButtonExit(self, event):
        self.signal_exit_button.emit()

    def onSignalLogRecord(self, record, **kwargs):
        # We may not be on the main thread. Push a callable in a queue object.
        self.print_queue.put(record.getMessage())
        if record.exc_info:
            for l in traceback.format_exception(*record.exc_info):
                self.print_queue.put(l)

    def _addText(self, msg):
        self.text_console.insert(tk.END, '%s\n' % msg)
        self.text_console.see(tk.END)

    def pump(self):
        self.parent.after(5, self.pump)
        while not self.print_queue.empty():
            msg = self.print_queue.get_nowait()
            self._addText(msg)


class ServiceRunner(threading.Thread):
    def __init__(self, conf, root):
        super(ServiceRunner, self).__init__()
        self.conf = conf
        self.root = root
        self.service_process = None

        self.signal_done = signalslot.Signal()

    def run(self):
        # Execute a resolve to reset and match up all the shortcut ids
        try:
            steam_devkit.utils.resolve.resolve_shortcuts()
        except (steam_devkit.utils.SteamClientNotRunningException, steam_devkit.utils.SteamClientNotRespondingException) as e:
            # The Steam client may not be running, or it could be sitting at the login prompt, where it won't respond to steam://devkit queries either
            logger.warning(e)
            logger.warning('Steam client is not running or not responding. Skipping installed games shortcut reconciliation.')

        service_path = shutil.which(SERVICE_EXECUTABLE_NAME)
        if service_path is None:
            logger.exception('FATAL: devkit service not found in PATH: %r', SERVICE_EXECUTABLE_NAME)
            return
        logger.info('%r found in PATH: %r', SERVICE_EXECUTABLE_NAME, service_path)

        entry_point_path = shutil.which(ENTRY_POINT_EXECUTABLE_NAME)
        if entry_point_path is None:
            logger.exception('FATAL: entry point for clients not found in PATH: %r', ENTRY_POINT_EXECUTABLE_NAME)
            return
        logger.info('%r found in PATH: %r', ENTRY_POINT_EXECUTABLE_NAME, entry_point_path)

        # Locate the hooks directory
        # TODO: identify when running out of a zipapp to help with this?
        # Check based on current directory first
        hooks_folder = None
        for check in '../hooks', 'hooks':
            folder = os.path.abspath(check)
            if os.path.isdir(folder):
                hooks_folder = folder
                logger.info('hooks folders found at: %r', hooks_folder)
                break
        if hooks_folder is None:
            raise Exception('FATAL: could not locate the hooks folder')
            return

        # Write our environment to a known location, so devkit-1-run-game can use it for standalone title launches
        environ_path = os.path.expanduser(
            os.path.join(
                os.getenv("HOME"),
                "devkit-game",
                "devkit-tool-environ.json"
            )
        )
        json.dump(
            dict(os.environ),
            open(environ_path, "w")
        )

        cmd = [service_path, '--hooks={0}'.format(hooks_folder), '--entry-point={0}'.format(entry_point_path)]
        env = copy.copy(os.environ)
        if self.conf.debug:
            env['G_MESSAGES_DEBUG'] = 'all'

        env['DEVKIT_BYPASS_STEAM_PROMPT'] = '1'

        logger.info('starting service: %r', cmd)
        self.service_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, env=env)
        while True:
            output = self.service_process.stdout.readline()
            if output == b'' and self.service_process.poll() is not None:
                break
            if output:
                logger.info(output.decode('utf-8').strip())
        exitcode = self.service_process.wait()
        logger.info('steamos-devkit-service process exited - code: %s', exitcode)
        self.signal_done.emit()

    def terminate(self, **kwargs):
        if self.service_process:
            # If the service is running, self.signal_done will emit after the process shuts down
            self.service_process.terminate()
            return
        # It is likely we are no longer running already.
        # Something bad happened in run and the signal didn't fire?
        self.signal_done.emit()

    def alive_monitor(self):
        # makes sure we exit if the thread stops running .. ticks in the main thread, uses tk for scheduling
        self.root.after(10, self.alive_monitor)
        if not self.is_alive():
            logger.info('service runner is inactive, forcing exit')
            self.signal_done.emit()


def main():
    logging_module.getLogger().setLevel(logging_module.INFO)
    logging_module.basicConfig()

    with steam_devkit.utils.create_pid(os.path.expanduser('~/devkit-game/devkit-tool.pid')) as pid_file:
        parser = argparse.ArgumentParser()
        parser.add_argument('--debug', required=False, action='store_true', help='debug verbosity')
        conf = parser.parse_args()

        if conf.debug:
            logging_module.getLogger().setLevel(logging_module.DEBUG)
        else:
            for h in logging_module.getLogger().handlers:
                h.setFormatter(logging_module.Formatter('%(message)s'))

        ui = UI(conf)
        root = tk.Tk()
        root.geometry('640x480')
        root.title("SteamOS Devkit Management Tool")
        ui.parent = root
        ui.setup()

        runner = ServiceRunner(conf, root)
        # Exit button on the UI kills the service process
        ui.signal_exit_button.connect(runner.terminate)
        # Service process thread exiting kills the UI and triggers exit
        runner.signal_done.connect(lambda **kwargs: root.quit())
        runner.start()

        root.after_idle(runner.alive_monitor)

        root.protocol("WM_DELETE_WINDOW", runner.terminate)
        root.mainloop()
